+++
id = "spacetime-lock"
title = "Add spacetime.lock for computed graph behavior"
type = "feature"
priority = 1
depends_on = ["spacetime-model"]
+++

## Problem

The `spacetime.toml` captures catalog metadata (nebula entries, manual annotations, relationships), but there's no place to store the computed graph behavior that relativity derives from this data: resolved dependency order, wave assignments, impact scores, centrality metrics, and the execution plan. Without a separate lock file, these computed artifacts must be re-derived on every invocation, and there's no way to detect when the catalog has changed and the computed state is stale.

This is analogous to `go.sum` alongside `go.mod` — the toml is the source of truth for what's tracked, the lock is the resolved/computed state.

## Solution

### Schema: `.relativity/spacetime.lock`

```toml
# Computed graph state — auto-generated, do not edit.
# Re-generated by: quasar relativity scan

[lock]
version = 1
generated_at = "2026-02-19T10:00:00Z"
source_hash = "sha256:abc123..."  # hash of spacetime.toml at generation time

# Topologically sorted execution order.
[graph]
order = ["tui-landing-page", "dag-engine", "relativity"]
waves = [
    ["tui-landing-page"],          # wave 1: no dependencies
    ["dag-engine", "relativity"],  # wave 2: depends on wave 1
]

# Per-nebula computed metrics.
[[metrics]]
name = "tui-landing-page"
wave = 1
impact_score = 0.85      # normalized 0-1 based on areas touched
centrality = 0.6         # graph centrality (how many nebulas depend on it)
downstream_count = 2     # number of nebulas transitively enabled
area_overlap = ["cmd"]   # areas shared with other nebulas

[[metrics]]
name = "dag-engine"
wave = 2
impact_score = 0.72
centrality = 0.3
downstream_count = 0
area_overlap = []

# Staleness detection.
[staleness]
nebula_count = 3                           # expected nebula count from toml
last_git_commit = "abc1234"                # HEAD at scan time
branch_tips = { "nebula/dag-engine" = "def5678" }  # tracked branch HEADs
```

### Go Data Model

```go
// internal/relativity/lock.go

// LockFile is the computed graph state derived from the catalog.
type LockFile struct {
    Version     int       `toml:"version"`
    GeneratedAt time.Time `toml:"generated_at"`
    SourceHash  string    `toml:"source_hash"`
    Graph       Graph     `toml:"graph"`
    Metrics     []Metric  `toml:"metrics"`
    Staleness   Staleness `toml:"staleness"`
}

// Graph captures the resolved dependency order and wave assignments.
type Graph struct {
    Order []string   `toml:"order"`
    Waves [][]string `toml:"waves"`
}

// Metric holds computed scores for a single nebula.
type Metric struct {
    Name            string   `toml:"name"`
    Wave            int      `toml:"wave"`
    ImpactScore     float64  `toml:"impact_score"`
    Centrality      float64  `toml:"centrality"`
    DownstreamCount int      `toml:"downstream_count"`
    AreaOverlap     []string `toml:"area_overlap"`
}

// Staleness holds data used to detect when the lock is out of date.
type Staleness struct {
    NebulaCount   int               `toml:"nebula_count"`
    LastGitCommit string            `toml:"last_git_commit"`
    BranchTips    map[string]string `toml:"branch_tips"`
}
```

### Lock Generation

After the scanner populates `spacetime.toml`, the lock generator:

1. **Parses the catalog** and builds an adjacency graph from `enables`/`builds_on` relationships
2. **Topological sort** produces the execution order
3. **Wave assignment** groups nebulas into parallel waves (same algorithm as the DAG engine)
4. **Metric computation** calculates impact scores (based on area count and package modifications), centrality (in-degree normalized), downstream counts, and area overlap with sibling nebulas
5. **Staleness snapshot** records the current toml hash, git HEAD, and tracked branch tips
6. **Writes** `.relativity/spacetime.lock`

### Staleness Detection

On subsequent scans, the lock is considered stale if any of:
- `source_hash` doesn't match the current `spacetime.toml` hash
- `nebula_count` differs from the current catalog
- `last_git_commit` doesn't match HEAD
- Any `branch_tips` have advanced

When stale, `quasar relativity scan` regenerates the lock automatically.

## Files

- `internal/relativity/lock.go` — LockFile, Graph, Metric, Staleness types
- `internal/relativity/lock_generate.go` — graph resolution, wave assignment, metric computation
- `internal/relativity/lock_staleness.go` — staleness detection (hash comparison, git check)
- `internal/relativity/lock_test.go` — round-trip serialization, staleness detection, metric accuracy

## Acceptance Criteria

- [ ] LockFile struct fully represents the schema above
- [ ] Lock generation produces correct topological order from catalog relationships
- [ ] Wave assignment groups independent nebulas into parallel waves
- [ ] Impact scores and centrality metrics are computed and normalized
- [ ] Staleness detection correctly identifies when the lock needs regeneration
- [ ] Lock file is regenerated automatically during `quasar relativity scan`
- [ ] Load/save round-trips without data loss
- [ ] `go test ./internal/relativity/...` passes