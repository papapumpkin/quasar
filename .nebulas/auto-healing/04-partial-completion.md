+++
id = "partial-completion"
title = "Carry forward partial work from failed phases into remediation context"
type = "feature"
priority = 2
depends_on = ["dag-insertion"]
labels = ["quasar", "auto-healing", "reliability"]
scope = ["internal/nebula/healing.go", "internal/nebula/worker.go"]
allow_scope_overlap = true
+++

## Problem

When a phase fails after several coder-reviewer cycles, it has typically produced real work: committed code changes, lint fixes, and partial progress toward the acceptance criteria. If the remediation phase starts from scratch without awareness of this partial work, it will:

1. Waste budget re-doing work that already exists on disk
2. Potentially conflict with or overwrite the failed phase's commits
3. Miss context about what was already tried and failed

The remediation phase's coder needs to understand: what commits were made, what files were touched, what the reviewer objected to, and what the current state of the code is.

## Solution

### Partial work snapshot

Add a struct to capture the partial work from a failed phase:

```go
// PartialWork captures the state of a phase's progress at the point of failure.
// It is injected into the remediation phase's coder prompt so the agent can
// build on existing work rather than starting from scratch.
type PartialWork struct {
    PhaseID       string
    CommitSHAs    []string // CycleState.CycleCommits — one SHA per completed cycle
    BaseCommitSHA string   // CycleState.BaseCommitSHA — HEAD before the phase started
    FilesTouched  []string // files modified across all commits (extracted via git diff)
    CyclesUsed    int
    LastFindings  []string // final cycle's reviewer findings (the unresolved objections)
}
```

Add a function to build it:

```go
// BuildPartialWork extracts a PartialWork snapshot from the failed phase's
// CycleState. The filesTouched list is computed by diffing BaseCommitSHA against
// the last CycleCommit SHA.
func BuildPartialWork(state *loop.CycleState, git GitDiffLister) (*PartialWork, error)
```

`GitDiffLister` is a small interface consumed where defined:

```go
// GitDiffLister lists files changed between two commits.
type GitDiffLister interface {
    DiffFileList(ctx context.Context, base, head string) ([]string, error)
}
```

The `Loop.Git` field (type `CycleCommitter`) or the existing `GitCommitter` interface on `WorkerGroup.Committer` can be extended or wrapped to satisfy this. Alternatively, use `exec.CommandContext(ctx, "git", "diff", "--name-only", base, head)` directly in the implementation.

### Prompt injection

Modify `BuildRemediationRequest` (from phase `02`) to accept an optional `*PartialWork` and include it in the architect prompt:

```
### Partial Work from Failed Phase
- Base commit: ${pw.BaseCommitSHA}
- Cycle commits: ${pw.CommitSHAs joined}
- Files touched: ${pw.FilesTouched bulleted}
- Cycles completed: ${pw.CyclesUsed}
- Unresolved findings:
${pw.LastFindings bulleted}

The remediation phase MUST NOT revert these commits. Build on the existing
changes and address only the unresolved findings listed above.
```

Additionally, the remediation phase's generated `PhaseSpec.Body` (the markdown body written by the architect) should include a `## Partial Work` section. This is handled by the architect's system prompt instruction (added in phase `02`).

### Remediation coder prompt context

When the remediation phase is executed by `WorkerGroup`, its `Loop` instance receives the task description from the `PhaseSpec.Body` generated by the architect. To further ground the coder, inject a `ProjectContext` block into the `Loop` configuration that includes:

```go
// healingContext returns a ProjectContext supplement for remediation phases.
func healingContext(pw *PartialWork) string
```

This returns a block like:

```
[AUTO-HEALING CONTEXT]
This phase remediates a prior failure. The following commits contain partial
work that you MUST preserve and build upon:
- ${commit SHAs}
Files already modified: ${file list}
Unresolved reviewer findings from the failed attempt:
- ${findings}
Do NOT revert existing changes. Focus on resolving the listed findings.
[END AUTO-HEALING CONTEXT]
```

This is prepended to the `Loop.ProjectContext` field when constructing the `Loop` for the remediation phase in `WorkerGroup.executePhase`.

### Storage of PartialWork

Store the `PartialWork` in a new field on `FailureDiagnosis`:

```go
type FailureDiagnosis struct {
    // ... existing fields ...
    PartialWork *PartialWork // populated when commits exist from the failed phase
}
```

This keeps all failure context in one struct and flows naturally through `BuildRemediationRequest`.

## Files

- `internal/nebula/healing.go` — add `PartialWork`, `BuildPartialWork`, `GitDiffLister`, `healingContext`; extend `FailureDiagnosis` with `PartialWork` field; update `BuildRemediationRequest` signature
- `internal/nebula/healing_test.go` — test `BuildPartialWork` with mock `GitDiffLister`; test prompt includes partial work section; test `healingContext` output format
- `internal/nebula/worker.go` — inject `healingContext` into `Loop.ProjectContext` when executing remediation phases

## Acceptance Criteria

- [ ] `BuildPartialWork` extracts commit SHAs, file list, and findings from `CycleState`
- [ ] `BuildPartialWork` returns empty `FilesTouched` gracefully when `BaseCommitSHA == ""` (no commits made)
- [ ] Architect prompt includes the `## Partial Work` section when `PartialWork` is non-nil
- [ ] Architect prompt omits the section entirely when `PartialWork` is nil (no cycles completed)
- [ ] `healingContext` output is injected into `Loop.ProjectContext` for remediation phase execution
- [ ] Remediation coder prompt explicitly instructs not to revert existing commits
- [ ] `go test ./internal/nebula/...` passes
- [ ] `go vet ./internal/nebula/...` clean
