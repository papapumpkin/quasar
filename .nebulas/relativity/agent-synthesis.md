+++
id = "agent-synthesis"
title = "Generate agent-consumable artifacts from the catalog"
type = "feature"
priority = 2
depends_on = ["catalog-reports"]
+++

## Problem

Reports are read-once. For AI agents to truly benefit from the nebula history, we need to produce durable artifacts that live in the repo and are automatically consumed: memory files, CLAUDE.md sections, and onboarding prompts. When a new nebula completes, these artifacts should update to reflect the new state of the world.

## Solution

### Artifact Types

#### 1. Memory File Generation

Produce Serena-compatible memory files (`.serena/memories/`) and Claude Code memory files that agents auto-load:

```markdown
# Codebase Evolution (auto-generated by relativity)

## Package Origins
- internal/tui: introduced by tui-landing-page (nebula 1)
- internal/dag: introduced by dag-engine (nebula 2)
- internal/relativity: introduced by relativity (nebula 3)

## Recent Changes
- dag-engine added PageRank and Betweenness scoring to internal/dag
- relativity added the nebula catalog system

## Architecture Decisions
- TUI uses bubbletea model/update/view
- DAG engine uses Facade + Strategy patterns
- Task scheduling uses Union-Find for parallel track partitioning
```

#### 2. CLAUDE.md Section

Generate a section that can be appended to or included in `CLAUDE.md`:

```markdown
## Codebase History (auto-generated by relativity)

This project has evolved through the following nebulas:
1. **tui-landing-page** — TUI home screen (completed)
2. **dag-engine** — DAG task dependency engine (in progress)
3. **relativity** — This catalog system (in progress)
```

#### 3. Onboarding Prompt Template

A ready-to-use prompt for onboarding a new AI agent:

```
You are being onboarded into the Quasar codebase. Here is the project's
evolution history, generated by the relativity system:

[full onboarding brief inserted here]

Your task is: [placeholder for the actual task]

Use the evolution history to understand why the code is structured the
way it is and which areas are stable vs actively changing.
```

### Synthesis Pipeline

```go
// Synthesizer produces agent-consumable artifacts from catalog data.
type Synthesizer struct {
    catalog *Spacetime
}

func (s *Synthesizer) GenerateMemory() (string, error)
func (s *Synthesizer) GenerateCLAUDESection() (string, error)
func (s *Synthesizer) GenerateOnboardingPrompt() (string, error)
func (s *Synthesizer) WriteAll(outputDir string) error
```

### Artifact Freshness

Each generated artifact includes a comment header:

```markdown
<!-- Generated by quasar relativity | last scan: 2026-02-18T12:00:00Z | do not edit below this line -->
```

Re-running the synthesizer replaces everything below that marker, preserving any manual content above it.

## Files

- `internal/relativity/synthesizer.go` — artifact generation logic
- `internal/relativity/synthesizer_test.go` — tests for each artifact type
- Templates embedded via `embed.FS` if needed

## Acceptance Criteria

- [ ] Memory file generation produces valid, useful agent context
- [ ] CLAUDE.md section is concise and accurate
- [ ] Onboarding prompt reads naturally and provides actionable context
- [ ] Re-generation preserves manual content above the marker
- [ ] Artifacts include freshness metadata (timestamp, scan info)
- [ ] `go test ./internal/relativity/...` passes